const FEED_CONFIGS = {
  // Add additional YouTube feeds here. Each key becomes the worker path segment.
  'cpscott16': {
    channelId: 'UCO1ydt_TOAZfwEgJpgOx2jQ',
    handle: 'CPScott16'
  },
  '404mediaco': {
    channelId: 'UC7YMZb0X_W06ToOazhFuXIQ',
    handle: '404Mediaco'
  },
  'jasonkpargin': {
    channelId: 'UCREK_lo_gv9fkQNxEzFTjwQ',
    handle: 'jasonkpargin'
  },
  'abettercomputer': {
    channelId: 'UCGYdWR8QUYn88lG0PBeJQ_g',
    handle: 'ABetterComputer'
  },
  'abetoday': {
    channelId: 'UCUxIu91gGsK9Q0tTcQM8iNw',
    handle: 'abetoday'
  },
  'hotweirdg0rl': {
    channelId: 'UCy_2BeNSAZXkdFlxOLj-IuQ',
    handle: 'hotweirdg0rl'
  },
  'roadshowpbs': {
    channelId: 'UCdnJJ2_mzqHwKIX_SmCVHTA',
    handle: 'RoadshowPBS'
  },
  'archdigest': {
    channelId: 'UC0k238zFx-Z8xFH0sxCrPJg',
    handle: 'Archdigest'
  },
  'artsy_story': {
    channelId: 'UCfSzGVdNy8YndcAw9Fmij5A',
    handle: 'artsy_story'
  },
  'atrocityguide': {
    channelId: 'UCn8OYopT9e8tng-CGEWzfmw',
    handle: 'AtrocityGuide'
  },
  'codingwithauryn': {
    channelId: 'UChk4F4yBtP4i063wnJH8TIQ',
    handle: 'CodingWithAuryn'
  },
  'austinkillsit': {
    channelId: 'UCAmjevylPV9bYMV-pG_4YCg',
    handle: 'austinkillsit'
  },
  'bekahdayyy': {
    channelId: 'UC_wQixk-qE9uxyB9AwjENsA',
    handle: 'bekahdayyy'
  },
  'palmertrolls': {
    channelId: 'UCBp_JNTbVgZx_6DFxSSY-Hg',
    handle: 'palmertrolls'
  },
  'beckystern': {
    channelId: 'UCsI_41SZafKtB5qE46WjlQQ',
    handle: 'BeckyStern'
  },
  'clemmygames': {
    channelId: 'UCCd3jyJmOFzkJEMj5Bp89rw',
    handle: 'clemmygames'
  },
  'bitluni': {
    channelId: 'UCp_5PO66faM4dBFbFFBdPSQ',
    handle: 'bitluni'
  },
  '_jared': {
    channelId: 'UC2Kyj04yISmHr1V-UlJz4eg',
    handle: '_jared'
  },
  'bleepingcomputer': {
    channelId: 'UCTU0ZJQ8Lqslww0R9Xk0sJg',
    handle: 'bleepingcomputer'
  },
  'mkbhd': {
    channelId: 'UCBJycsmduvYEL83R_U4JriQ',
    handle: 'mkbhd'
  },
  'halloftechllc': {
    channelId: 'UCJSJ0xIWf4e3hNu7KgYqPxg',
    handle: 'HallOfTechLLC'
  },
  'landonsanimationwheelhouse': {
    channelId: 'UC2WJrMmd_eNMqfWJbD_fq2A',
    handle: 'LandonsAnimationWheelhouse'
  },
  'brickexperimentchannel': {
    channelId: 'UClsFdM0HzTdF1JYoraQ0aUw',
    handle: 'BrickExperimentChannelationWheelhouse'
  },
  'brick_crafts': {
    channelId: 'UCTGHqw41qk_WyK3wJK7nweg',
    handle: 'Brick_Crafts'
  },
  'brynodc': {
    channelId: 'UCNG4L6tzJq1i8gWkbmuMoiA',
    handle: 'brynoDC'
  },
  'snaptocks': {
    channelId: 'UCNG4L6tzJq1i8gWkbmuMoiA',
    handle: 'snaptocks'
  },
  'filamentfriday': {
    channelId: 'UCsdc_0ZTXikARFEn2dRDJhg',
    handle: 'FilamentFriday'
  },
  'chuntzit': {
    channelId: 'UCghR6gNuBneEKkDuKtXQM4w',
    handle: 'Chuntzit'
  },
  'clickandthock': {
    channelId: 'UCxsWMZAyUwT67nikED3sL_g',
    handle: 'ClickandThock'
  },
  'cnet': {
    channelId: 'UC9-y-6csu5WGm29I7JiwpnA',
    handle: 'CNET'
  },
  'damileearch': {
    channelId: 'UCJ_2hNMxOzNjviJBiLWHMqg',
    handle: 'DamiLeeArch'
  },
  'danharumi1': {
    channelId: 'UCVAgplWvY5nT90yI2Rq2HkA',
    handle: 'danharumi1'
  },
  'maklelan': {
    channelId: 'UCAAJCQ0FCqRmAEv95SyTfNg',
    handle: 'maklelan'
  },
  //!!!!!!!!!!!!!!!!!!!!!!!!
  'danreedermusic': {
    channelId: 'UCZQVGv2GGRSOeVTQMYoru2A',
    handle: 'DanReederMusic'
  },
  'maklelan': {
    channelId: 'UCAAJCQ0FCqRmAEv95SyTfNg',
    handle: 'maklelan'
  },
  'davesgarage': {
    channelId: 'UCNzszbnvQeFzObW0ghk0Ckw',
    handle: 'DavesGarage'
  },
  'drloriv': {
    channelId: 'UCyld4DZKdnx-VcH0mqpOClg',
    handle: 'DrLoriV'
  },
  'ebnovels': {
    channelId: 'UCiflcKnh5cZiRWK7jlYKwxA',
    handle: 'ebnovels'
  },
  //!!!!!!!!!!!!!!!!!!!!!!!!!
  'emmymade': {
    channelId: 'UC9-y-UCzqbfYjQmf9nLQPMxVgPhiA',
    handle: 'emmymade'
  },
  'etymology_nerd': {
    channelId: 'UCNHb7I85BKnwbJF4fWBXJjA',
    handle: 'etymology_nerd'
  },
  'feypop': {
    channelId: 'UCgBvWtknPuHpVuytBgkiXyA',
    handle: 'feypop'
  },
  'fourkeysbookarts': {
    channelId: 'UCwjz7_xH_1Sehw5W-qIDLeg',
    handle: 'FourKeysBookArts'
  },
  //!!!!!!!!!!!!!!!!!!!!!!
  'geohussar': {
    channelId: 'UCEW-UCEW-70kkxTIsxPeXJtdVaeg',
    handle: 'GeoHussar'
  },
  'hqkay': {
    channelId: 'UCnj_D0bV_fZ2p0BdBsUOcYA',
    handle: 'HQKAY'
  },
  'ifixityourself': {
    channelId: 'UCHbx9IUW7eCeJsC4sBCTNBA',
    handle: 'iFixitYourself'
  },
  'democracynow': {
    channelId: 'UCzuqE7-t13O4NIDYJfakrhw',
    handle: 'DemocracyNow'
  },
  'jennynicholson': {
    channelId: 'UC7-E5xhZBZdW-8d7V80mzfg',
    handle: 'JennyNicholson'
  },
  'jerryrigeverything': {
    channelId: 'UCWFKCr40YwOZQx8FHU_ZqqQ',
    handle: 'JerryRigEverything'
  },
  'keds_economist': {
    channelId: 'UC-L8bPaJ_aJznCLLtUHxnLA',
    handle: 'keds_economist'
  },
  'lastweektonight': {
    channelId: 'UC3XTzVzaHQEd30rQbuvCtTQ',
    handle: 'LastWeekTonight'
  },
  'learnlinuxtv': {
    channelId: 'UCxQKHvKbmSzGMvUrVtJYnUA',
    handle: 'LearnLinuxTV'
  },
  'limc': {
    channelId: 'UCaHT88aobpcvRFEuy4v5Clg',
    handle: 'LIMC'
  },
  'lorde': {
    channelId: 'UCOxhwqKKlVq_NaD0LVffGuw',
    handle: 'Lorde'
  },
  'matteolanecomedy': {
    channelId: 'UC9-UCHtaXqDklDTydmwgLj5siMg-6csu5WGm29I7JiwpnA',
    handle: 'matteolanecomedy'
  },
  'michael_tunnell': {
    channelId: 'UCmyGZ0689ODyReHw3rsKLtQ',
    handle: 'michael_tunnell'
  },
  'gremlita': {
    channelId: 'UCoOss5XiPpnLHGmLrBvNkJg',
    handle: 'gremlita'
  },
  'maklelan': {
    channelId: 'UCsJ-VTlxYSKG-UVHa7K1Khw',
    handle: 'maklelan'
  },
  'mk.gee_': {
    channelId: 'UCsJ-VTlxYSKG-UVHa7K1Khw',
    handle: 'mk.gee_'
  },
  'molesrcoool': {
    channelId: 'UCNvIUYKjBXoMVcL0bTRUqhQ',
    handle: 'molesrcoool'
  },
  'molly0xfff': {
    channelId: 'UCJcWDNh9E6AoVW4nsMXyVCw',
    handle: 'molly0xfff'
  },
  'moonsrarebooks': {
    channelId: 'UCPCoaKCeqmWhCwCH5Ht7dQg',
    handle: 'MoonsRareBooks'
  },
  'networkchuck': {
    channelId: 'UC9x0AN7BWHpCDHSm9NiJFJQ',
    handle: 'NetworkChuck'
  },
  'nikfromtiktok': {
    channelId: 'UCOADp5jDxyAffcTNFvumbQA',
    handle: 'NikFromTikTok'
  },
  'nprmusic': {
    channelId: 'UC4eYXhJI4-7wSWc8UNRwD4A',
    handle: 'nprmusic'
  },
  'oceanna_': {
    channelId: 'UClFk1sJv-6eSJNHejjvf-6g',
    handle: 'oceanna_'
  },
  'outlawbookselleroriginal': {
    channelId: 'UCcpaYAc_kJbYBP66YQpxRnw',
    handle: 'OfficeHoursLive'
  },
  'pingpingtechtalk': {
    channelId: 'UCYNIKXaDBl8DZ5FyxFivXhg',
    handle: 'PingPingTechTalk'
  },
  'jayduck9': {
    channelId: 'UCB3gITkN1-LzFF_IpVanURQ',
    handle: 'jayduck9'
  },
  'officehourslive': {
    channelId: 'UCtS3BcCw-tITPFYSvkbP0Bg',
    handle: 'OfficeHoursLive'
  },
  'drrachelbarr': {
    channelId: 'UCC6wU8VRgIYizEjVvTdalMQ',
    handle: 'DrRachelBarr'
  },
  'ramjad': {
    channelId: 'UCLA7cJBnqr0nLF2bQBD9uUg',
    handle: 'RAmjad'
  },
  'rebecca.romney': {
    channelId: 'UC8_ejtUg86uwyerNtmx5D4g',
    handle: 'rebecca.romney'
  },
  'rottenmangopod': {
    channelId: 'UCZnXNjnBhrrmvx3eDO_2z9w',
    handle: 'rottenmangopod'
  },
  'rottentomatoestrailers': {
    channelId: 'UCi8e0iOVk1fEOogdfu4YgfA',
    handle: 'RottenTomatoesTRAILERS'
  },
  'thesiliconsiren': {
    channelId: 'UCC9uI0zEXkiRFgctyTLegRg',
    handle: 'theSiliconSiren'
  },
  'simoncaine9515': {
    channelId: 'UC0HAW8tgFA_xEmeUupuRwiA',
    handle: 'simoncaine9515'
  },
  'StanWinstonSchool': {
    channelId: 'UCnuYvkjI5C1HzYq9dfs2Nsg',
    handle: 'OfficeHoursLive'
  },
  'sir_superhero': {
    channelId: 'UCnuYvkjI5C1HzYq9dfs2Nsg',
    handle: 'sir_superhero'
  },
  'stanwinstonschool': {
    channelId: 'UC1rKAv7IwCeynqa9MPNfYaA',
    handle: 'StanWinstonSchool'
  },
  'officehourslive': {
    channelId: 'UCtS3BcCw-tITPFYSvkbP0Bg',
    handle: 'OfficeHoursLive'
  },
  'stavvysworld': {
    channelId: 'UCBVAaHkKSwfzee79b7SPyPw',
    handle: 'stavvysworld'
  },
  'SwitchandClickOfficial': {
    channelId: 'UCT6AJiTYspOILBK3hMWEq2g',
    handle: 'SwitchandClickOfficial'
  },
  'jamelle-bouie': {
    channelId: 'UCgDA-Or474NOdFEF8WF2yCA',
    handle: 'jamelle-bouie'
  },
  'taramooknee': {
    channelId: 'UCT5C7yaO3RVuOgwP8JVAujQ',
    handle: 'TaraMooknee'
  },
  'taskmaster': {
    channelId: 'UCT5C7yaO3RVuOgwP8JVAujQ',
    handle: 'taskmaster'
  },
  'taylorlorenz': {
    channelId: 'UCp38w5n099xkvoqciOaeFag',
    handle: 'TaylorLorenz'
  },
  'theadamfriedlandshow': {
    channelId: 'UC6ext5UAbrLT2e5y5BC6RTQ',
    handle: 'TheAdamFriedlandShow'
  },
  'theboboyspodcast': {
    channelId: 'UCtvC3nAHWPr6Ztc9PfB3eIA',
    handle: 'theboboyspodcast'
  },
  'thedailyshow': {
    channelId: 'UCUNOwz9KTDIhhTTN3_ptUDA',
    handle: 'TheDailyShow'
  },
  'thegoodliars': {
    channelId: 'UCUNOwz9KTDIhhTTN3_ptUDA',
    handle: 'TheGoodLiars'
  },
  'katetheunreal': {
    channelId: 'UCbORPu-PNMrFe9fVZ_Xu0VA',
    handle: 'Katetheunreal'
  },
  'thelinuxchannel': {
    channelId: 'UCESk3ORdKJ1iQGibV_XiHhw',
    handle: 'TheLinuxChannel'
  },
  'thelinuxexp': {
    channelId: 'UC5UAwBUum7CPN5buc-_N1Fw',
    handle: 'TheLinuxEXP'
  },
  'therestisentertainment': {
    channelId: 'UCYJpsKWYfZU8kOHZf_tUzQw',
    handle: 'TheRestIsEntertainment'
  },
  'theverge': {
    channelId: 'UCddiUEpeqJcYeBxX1IVBKvQ',
    handle: 'TheVerge'
  },
  'tibees': {
    channelId: 'UC52kszkc08-acFOuogFl5jw',
    handle: 'tibees'
  },
  'tom_nicholas': {
    channelId: 'UCxt2r57cLastdmrReiQJkEg',
    handle: 'Tom_Nicholas'
  },
  'tondoeslinux': {
    channelId: 'UCUDdGb82Xsv4_LQprelLhqA',
    handle: 'TonDoesLinux'
  },
  'twinflicks': {
    channelId: 'UCQG4l7WZRN_v8eI3tFtkHsQ',
    handle: 'TwinFlicks'
  },
  'under_1_min': {
    channelId: 'UCAq7apXGmB81wXmApvJ7kng',
    handle: 'Under_1_min'
  },
  'vanityfair': {
    channelId: 'UCIsbLox_y9dCIMLd8tdC6qg',
    handle: 'VanityFair'
  },
  'veritasium': {
    channelId: 'UCHnyfMqiRRG1u-2MsSQLbXA',
    handle: 'veritasium'
  },
  'veronicaexplains': {
    channelId: 'UCMiyV_Ib77XLpzHPQH_q0qQ',
    handle: 'VeronicaExplains'
  },
  'vfxgeek': {
    channelId: 'UC0XxzKQ-zNekAIJMAMrdXVA',
    handle: 'VFXGeek'
  },
  'vizuara': {
    channelId: 'UCdEov4L0bpJ_h6W3sJxkfUA',
    handle: 'vizuara'
  },
  'yharazayd': {
    channelId: 'UCzuvcjgZyyMaO6gwidRT8GA',
    handle: 'Yharazayd'
  },
  'yharazayd': {
    channelId: 'UCeTQM2-L710Mcqf6OAh9UUg',
    handle: 'Yharazayd'
  },
  'vanityfair': {
    channelId: 'UCIsbLox_y9dCIMLd8tdC6qg',
    handle: 'VanityFair'
  },
  'veritasium': {
    channelId: 'UCHnyfMqiRRG1u-2MsSQLbXA',
    handle: 'veritasium'
  },
  'fdsignifire': {
    channelId: 'UCgi2u-lGY-2i2ubLsUr6FbQ',
    handle: 'fdsignifire'
  }
};

const DEFAULT_CONFIG = {
  cacheDuration: 300,
  sourceCacheTTLMin: 3 * 3600,
  sourceCacheTTLMax: 3 * 3600
};

const PROVIDER_PRIORITY = [
  { type: 'youtube', host: 'https://www.youtube.com', mode: 'page', key: 'youtube-page' }
  { type: 'invidious', host: 'https://inv.nadeko.net', mode: 'embed', key: 'inv-nadeko-embed' },
  { type: 'invidious', host: 'https://yewtu.be', mode: 'embed', key: 'yewtu-embed' },
  { type: 'invidious', host: 'https://invidious.f5.si', mode: 'embed', key: 'f5si-embed' },
  { type: 'youtube', host: 'https://www.youtube.com', mode: 'embed', key: 'youtube-embed' },
  { type: 'invidious', host: 'https://inv.nadeko.net', mode: 'page', key: 'inv-nadeko-page' },
  { type: 'invidious', host: 'https://yewtu.be', mode: 'page', key: 'yewtu-page' },
  { type: 'invidious', host: 'https://invidious.f5.si', mode: 'page', key: 'f5si-page' },
];

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const pathSegments = url.pathname.split('/').filter(Boolean);
    const feedKey = pathSegments[0]?.toLowerCase();

    let feedConfig;

    if (feedKey && FEED_CONFIGS[feedKey]) {
      feedConfig = {
        ...DEFAULT_CONFIG,
        ...FEED_CONFIGS[feedKey],
        cacheKey: `feed_${feedKey}`
      };
      feedConfig.url = resolveYouTubeFeedUrl(feedConfig);
    } else {
      const feedUrl = url.searchParams.get('feed');
      if (!feedUrl) {
        return createErrorResponse(
          'Usage:\n' +
          '1. Predefined feeds: https://your-worker.dev/feedname\n' +
          '2. Dynamic feeds: https://your-worker.dev/?feed=RSS_URL',
          400
        );
      }

      feedConfig = {
        ...DEFAULT_CONFIG,
        url: feedUrl,
        cacheKey: `feed_${hashString(feedUrl)}`
      };
    }

    try {
      const processedFeed = await processFeed(feedConfig, env);
      const rewrittenFeed = rewriteFeedSelfLink(processedFeed, url.toString());

      return new Response(rewrittenFeed, {
        headers: {
          'Content-Type': 'application/rss+xml; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0',
          'Access-Control-Allow-Origin': '*',
          'X-Feed-Source': feedConfig.url,
          'X-Feed-Processed': new Date().toISOString()
        }
      });
    } catch (error) {
      console.error('Feed processing error:', error);
      return createErrorResponse(`Error processing feed: ${error.message}`, 500);
    }
  }
};

async function processFeed(config, env) {
  const cacheKey = `source_${config.cacheKey}`;
  let feedXml = null;

  if (env.YOUTUBE_FEED_CACHE) {
    try {
      const cached = await env.YOUTUBE_FEED_CACHE.get(cacheKey, { type: 'json' });
      if (cached && cached.content && cached.timestamp) {
        const cacheAge = Date.now() - cached.timestamp;
        if (cacheAge < config.sourceCacheTTLMax * 1000) {
          feedXml = cached.content;
        }
      }
    } catch (error) {
      console.error('Error reading cache:', error);
    }
  }

  if (!feedXml) {
    if (!config.url) {
      throw new Error('Feed URL is not configured.');
    }

    const response = await fetch(config.url, {
      headers: {
        'User-Agent': 'YouTube-RSS-Embed-Worker/1.0 (Polite 3h cache)'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch feed: ${response.status} ${response.statusText}`);
    }

    feedXml = await response.text();

    if (env.YOUTUBE_FEED_CACHE) {
      const ttl = Math.floor(
        Math.random() * (config.sourceCacheTTLMax - config.sourceCacheTTLMin) + config.sourceCacheTTLMin
      );

      try {
        await env.YOUTUBE_FEED_CACHE.put(cacheKey, JSON.stringify({
          content: feedXml,
          timestamp: Date.now()
        }), {
          expirationTtl: ttl
        });
      } catch (error) {
        console.error('Error caching source feed:', error);
      }
    }
  }

  const providerCache = new Map();
  const isAtom = feedXml.includes('<feed') && feedXml.includes('xmlns="http://www.w3.org/2005/Atom"');
  return isAtom ? await processAtomFeed(feedXml, providerCache) : await processRssFeed(feedXml, providerCache);
}

async function processRssFeed(xmlString, providerCache) {
  const itemRegex = /<item\b[^>]*>[\s\S]*?<\/item>/gi;
  const matches = [...xmlString.matchAll(itemRegex)];
  if (matches.length === 0) return xmlString;

  let result = '';
  let lastIndex = 0;
  for (const match of matches) {
    const { index } = match;
    const fullItem = match[0];
    result += xmlString.slice(lastIndex, index);
    const rewritten = await rewriteRssItem(fullItem, providerCache);
    result += rewritten;
    lastIndex = index + fullItem.length;
  }
  result += xmlString.slice(lastIndex);
  return result;
}

async function processAtomFeed(xmlString, providerCache) {
  const entryRegex = /<entry\b[^>]*>[\s\S]*?<\/entry>/gi;
  const matches = [...xmlString.matchAll(entryRegex)];
  if (matches.length === 0) return xmlString;

  let result = '';
  let lastIndex = 0;
  for (const match of matches) {
    const { index } = match;
    const fullEntry = match[0];
    result += xmlString.slice(lastIndex, index);
    const rewritten = await rewriteAtomEntry(fullEntry, providerCache);
    result += rewritten;
    lastIndex = index + fullEntry.length;
  }
  result += xmlString.slice(lastIndex);
  return result;
}

async function rewriteRssItem(itemXml, providerCache) {
  const videoId = extractVideoIdFromContent(itemXml);
  if (!videoId) return itemXml;

  const preferredUrl = await getPreferredVideoUrl(videoId, providerCache);
  let updated = itemXml;
  updated = rewriteTextTag(updated, 'link', preferredUrl);
  updated = rewriteTextTag(updated, 'guid', preferredUrl);
  updated = rewriteMediaContentUrls(updated, preferredUrl);
  return updated;
}

async function rewriteAtomEntry(entryXml, providerCache) {
  const videoId = extractVideoIdFromContent(entryXml);
  if (!videoId) return entryXml;

  const preferredUrl = await getPreferredVideoUrl(videoId, providerCache);
  let updated = entryXml;
  updated = rewriteLinkAttributes(updated, preferredUrl);
  updated = rewriteTextTag(updated, 'id', preferredUrl);
  updated = rewriteMediaContentUrls(updated, preferredUrl);
  return updated;
}

function rewriteTextTag(xmlFragment, tagName, newUrl) {
  if (!newUrl) return xmlFragment;
  const regex = new RegExp(`<${tagName}\\b[^>]*>([\\s\\S]*?)<\\/${tagName}>`, 'i');
  const escaped = escapeXmlText(newUrl);
  return xmlFragment.replace(regex, (match, inner) => match.replace(inner, escaped));
}

function rewriteLinkAttributes(xmlFragment, newUrl) {
  if (!newUrl) return xmlFragment;
  const regex = /<link\b([^>]*?)href=["']([^"']+)["']([^>]*?)>/gi;
  const escaped = escapeXmlAttribute(newUrl);
  return xmlFragment.replace(regex, (match, _prefix, url) => match.replace(url, escaped));
}

function rewriteMediaContentUrls(xmlFragment, newUrl) {
  if (!newUrl) return xmlFragment;
  const regex = /(<media:content\b[^>]*url=["'])([^"']+)(["'][^>]*>)/gi;
  const escaped = escapeXmlAttribute(newUrl);
  return xmlFragment.replace(regex, (match, prefix, _url, suffix) => `${prefix}${escaped}${suffix}`);
}

async function getPreferredVideoUrl(videoId, providerCache) {
  for (const provider of PROVIDER_PRIORITY) {
    const cacheKey = provider.key;
    let status = providerCache.get(cacheKey);
    if (status === undefined) {
      status = await isProviderReachable(provider, videoId);
      providerCache.set(cacheKey, status);
    }
    if (status) {
      return buildProviderUrl(provider, videoId);
    }
  }
  return `https://www.youtube.com/watch?v=${videoId}`;
}

async function isProviderReachable(provider, videoId) {
  const testUrl = buildProviderUrl(provider, videoId);
  if (!testUrl) return false;

  try {
    let response = await fetch(testUrl, {
      method: 'HEAD',
      redirect: 'manual'
    });

    if (response.status === 405 || response.status === 501) {
      response = await fetch(testUrl, {
        method: 'GET',
        redirect: 'manual'
      });
    }

    return response.ok;
  } catch (error) {
    console.error(`Provider check failed for ${provider.key}:`, error);
    return false;
  }
}

function buildProviderUrl(provider, videoId) {
  const host = provider.host.replace(/\/+$/, '');
  if (provider.type === 'invidious') {
    if (provider.mode === 'embed') {
      return `${host}/embed/${videoId}`;
    }
    return `${host}/watch?v=${videoId}`;
  }

  if (provider.type === 'youtube') {
    if (provider.mode === 'embed') {
      return `${host}/embed/${videoId}?rel=0`;
    }
    return `${host}/watch?v=${videoId}`;
  }

  return null;
}

function extractVideoIdFromContent(xmlFragment) {
  const ytMatch = xmlFragment.match(/<yt:videoid[^>]*>([\s\S]*?)<\/yt:videoid>/i);
  if (ytMatch) return ytMatch[1].trim();

  const linkMatch = xmlFragment.match(/<link\b[^>]*>([\s\S]*?)<\/link>/i);
  if (linkMatch) {
    const id = extractYouTubeVideoId(decodeXmlEntities(linkMatch[1].trim()));
    if (id) return id;
  }

  const linkAttrMatch = xmlFragment.match(/<link\b[^>]*href=["']([^"']+)["'][^>]*>/i);
  if (linkAttrMatch) {
    const id = extractYouTubeVideoId(decodeXmlEntities(linkAttrMatch[1]));
    if (id) return id;
  }

  const guidMatch = xmlFragment.match(/<guid\b[^>]*>([\s\S]*?)<\/guid>/i);
  if (guidMatch) {
    const id = extractYouTubeVideoId(decodeXmlEntities(guidMatch[1].trim()));
    if (id) return id;
  }

  const mediaMatch = xmlFragment.match(/<media:content\b[^>]*url=["']([^"']+)["'][^>]*>/i);
  if (mediaMatch) {
    const id = extractYouTubeVideoId(decodeXmlEntities(mediaMatch[1]));
    if (id) return id;
  }

  return null;
}

function extractYouTubeVideoId(url) {
  const normalized = url.replace(/\s+/g, '');

  try {
    const parsed = new URL(normalized);
    const host = parsed.hostname.toLowerCase();

    if (host.includes('youtu.be')) {
      const segments = parsed.pathname.split('/').filter(Boolean);
      if (segments[0]) return segments[0];
    }

    if (host.includes('youtube.com')) {
      const vParam = parsed.searchParams.get('v');
      if (vParam) return vParam;

      const parts = parsed.pathname.split('/').filter(Boolean);
      if (['shorts', 'live', 'embed'].includes(parts[0])) {
        return parts[1] || null;
      }

      if (parts[0] === 'watch' && parts[1]) {
        return parts[1];
      }
    }
  } catch (error) {
    // Fall back to regex below
  }

  const fallback = normalized.match(/([A-Za-z0-9_-]{11})/);
  return fallback ? fallback[1] : null;
}

function rewriteFeedSelfLink(feedXml, selfUrl) {
  if (!feedXml || !selfUrl) return feedXml;
  const escapedUrl = escapeXmlAttribute(selfUrl);
  const patterns = [
    /(<link\b[^>]*rel=["']self["'][^>]*href=["'])([^"']+)(["'][^>]*>)/i,
    /(<atom:link\b[^>]*rel=["']self["'][^>]*href=["'])([^"']+)(["'][^>]*>)/i
  ];

  let updatedXml = feedXml;
  for (const pattern of patterns) {
    updatedXml = updatedXml.replace(pattern, `$1${escapedUrl}$3`);
  }
  return updatedXml;
}

function decodeXmlEntities(value) {
  return value
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");
}

function escapeXmlAttribute(value) {
  return value
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function escapeXmlText(value) {
  return value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function hashString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0;
  }
  return Math.abs(hash).toString(36);
}

function createErrorResponse(message, status = 500) {
  return new Response(message, {
    status,
    headers: {
      'Content-Type': 'text/plain',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

function resolveYouTubeFeedUrl(config) {
  if (config.url) return config.url;
  if (config.channelId) {
    return `https://www.youtube.com/feeds/videos.xml?channel_id=${config.channelId}`;
  }
  if (config.handle) {
    return `https://www.youtube.com/feeds/videos.xml?user=${config.handle}`;
  }
  return null;
}
